<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>CYOA Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="/static/js/recorder.js"></script>
    <style>
        [x-cloak] { display: none !important; }
        html, body { 
            height: 100%; 
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        /* Level meter animation */
        .level-bar {
            transition: height 0.05s ease-out;
        }
        
        /* Pulse animation for recording indicator */
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse-red {
            animation: pulse-red 1s ease-in-out infinite;
        }
    </style>
</head>
<body class="h-full">
<div
  x-data="chatApp()"
  x-init="init()"
  class="h-full flex flex-col bg-white"
>
  <!-- Fixed Top: Navigation + Game State -->
  <div class="flex-none border-b border-gray-300 bg-white">
    <!-- Navigation Bar -->
    <div class="flex items-center justify-between px-2 py-1 border-b border-gray-200">
      <a href="/" class="flex items-center gap-1 px-2 py-1 text-indigo-600 hover:text-indigo-800 text-sm font-medium">
        <span>‚Üê</span>
        <span>Home</span>
      </a>
      <div class="flex-1 text-center">
        <h1 class="text-sm font-bold text-gray-800">Choose Your Own Adventure</h1>
      </div>
      <button
        @click="newConversation()"
        class="px-2 py-1 bg-indigo-600 text-white rounded text-sm font-medium hover:bg-indigo-700"
        title="Start new adventure"
      >
        New Adventure
      </button>
    </div>

    <!-- Game State -->
    <div class="px-2 py-1 flex items-center gap-2">
      <!-- Inventory -->
      <div class="flex-1 min-w-0">
        <div class="text-[10px] text-gray-500 uppercase tracking-wide leading-none mb-0.5">Inventory</div>
        <div class="flex gap-1 overflow-x-auto">
          <template x-if="inventoryItems.length === 0">
            <span class="text-xs text-gray-500">Empty</span>
          </template>
          <template x-for="(item, idx) in inventoryItems" :key="idx">
            <span class="text-[11px] px-1.5 py-0.5 bg-gray-100 text-gray-800 rounded border border-gray-200 whitespace-nowrap">
              <span x-text="item"></span>
            </span>
          </template>
        </div>
      </div>

      <!-- Turn Counter (only show if game started) -->
      <div x-show="gameStarted" class="flex-none text-right leading-tight">
        <div class="text-[10px] text-gray-500 uppercase tracking-wide leading-none">Turn</div>
        <div class="text-sm text-gray-800 font-medium" x-text="`${turnCurrent}/${turnMax}`"></div>
      </div>
    </div>
  </div>

  <!-- Scrollable Chat Messages (fills remaining space) -->
  <div class="flex-1 overflow-y-auto px-2 py-2 space-y-1.5" x-ref="messagesContainer">
    <template x-for="(message, index) in messages" :key="index">
      <div>
        <div
          :class="{
            'bg-indigo-600 text-white text-right': message.role === 'user',
            'bg-red-50 text-red-900 border border-red-200': message.role === 'assistant' && (message.is_error || (message.metadata && message.metadata.is_error)),
            'bg-gray-100 text-gray-900': message.role === 'assistant' && !message.is_error && !(message.metadata && message.metadata.is_error)
          }"
          class="w-full px-2 py-1.5 rounded-lg relative"
        >
          <div class="whitespace-pre-wrap text-[14px] leading-snug" x-text="message.content"></div>
          <!-- Refusal indicator for assistant messages -->
          <button
            x-show="message.role === 'assistant' && (message.refusal_info || (message.metadata && message.metadata.refusal_info))"
            @click="viewRefusalDetails(message)"
            class="absolute top-1 right-1 w-5 h-5 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center text-xs hover:bg-blue-200 transition-colors shadow-sm"
            title="View refusal details"
          >
            ‚ìò
          </button>
          <!-- Judge indicator for assistant messages -->
          <button
            x-show="message.role === 'assistant' && (message.judge_info || (message.metadata && message.metadata.judge_info))"
            @click="viewJudgeDetails(message)"
            class="absolute top-1 right-7 w-5 h-5 rounded-full bg-purple-100 text-purple-700 flex items-center justify-center text-xs hover:bg-purple-200 transition-colors shadow-sm"
            title="View judge details"
          >
            ‚öñÔ∏é
          </button>
        </div>
      </div>
    </template>

    <!-- Loading indicator -->
    <div x-show="isLoading">
      <div class="bg-gray-100 text-gray-900 w-full px-2 py-1.5 rounded-lg">
        <div class="flex items-center gap-1.5">
          <div class="flex gap-1">
            <div class="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms"></div>
            <div class="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms"></div>
            <div class="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Error display -->
    <div x-show="errorMessage" class="p-2 bg-red-50 border border-red-200 rounded">
      <p class="text-red-800 text-xs" x-text="errorMessage"></p>
    </div>
  </div>

  <!-- Fixed Bottom: Controls -->
  <div class="flex-none border-t border-gray-300 bg-gray-50 px-2 pt-1.5 pb-[calc(env(safe-area-inset-bottom,0px)+6px)]">
    
    <!-- Recording HUD (replaces composer when recording/processing/error) -->
    <div x-show="recorderState !== 'idle' && recorderState !== 'success'" x-cloak class="space-y-2">
      
      <!-- Recording state: show level meter + timer + stop button -->
      <template x-if="recorderState === 'recording'">
        <div class="space-y-2">
          <!-- Level meter -->
          <div class="h-12 bg-gray-200 rounded flex items-end justify-center gap-0.5 px-1 overflow-hidden" x-ref="levelMeterContainer">
            <template x-for="i in 32" :key="i">
              <div 
                class="level-bar bg-red-500 rounded-t w-2"
                :style="`height: ${Math.max(4, recorderLevel * 100 * (0.5 + Math.random() * 0.5))}%`"
              ></div>
            </template>
          </div>
          
          <!-- Timer and controls -->
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2">
              <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse-red"></div>
              <span class="text-lg font-mono font-bold text-gray-800" x-text="recorderTimeDisplay">00:00</span>
            </div>
            
            <div class="flex gap-2">
              <button
                @click="cancelRecording()"
                class="px-3 py-1.5 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 text-sm font-medium"
              >
                Cancel
              </button>
              <button
                @click="stopRecording()"
                class="px-4 py-1.5 bg-red-600 text-white rounded hover:bg-red-700 text-sm font-medium"
              >
                ‚èπ Stop
              </button>
            </div>
          </div>
        </div>
      </template>
      
      <!-- Processing state: show spinner + status -->
      <template x-if="recorderState === 'processing'">
        <div class="py-4 text-center space-y-2">
          <div class="flex justify-center">
            <svg class="animate-spin h-8 w-8 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          </div>
          <p class="text-sm text-gray-600">Transcribing audio...</p>
          <p class="text-xs text-gray-500">Your recording is saved locally. You can refresh and retry if needed.</p>
        </div>
      </template>
      
      <!-- Error state: show error + retry/discard buttons -->
      <template x-if="recorderState === 'error'">
        <div class="py-3 space-y-3">
          <div class="p-3 bg-red-50 border border-red-200 rounded">
            <p class="text-red-800 text-sm font-medium">Transcription failed</p>
            <p class="text-red-700 text-xs mt-1" x-text="recorderError">Unknown error</p>
          </div>
          
          <div class="flex gap-2 justify-center">
            <button
              @click="downloadRecording()"
              class="px-3 py-1.5 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 text-sm"
              title="Download recording"
            >
              üíæ Download
            </button>
            <button
              @click="discardRecording()"
              class="px-3 py-1.5 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 text-sm font-medium"
            >
              Discard
            </button>
            <button
              @click="retryTranscription()"
              class="px-4 py-1.5 bg-indigo-600 text-white rounded hover:bg-indigo-700 text-sm font-medium"
            >
              üîÑ Retry
            </button>
          </div>
          
          <p class="text-xs text-gray-500 text-center">
            Your recording is saved. You can retry or download it.
          </p>
        </div>
      </template>
    </div>
    
    <!-- Normal composer UI (when not recording) -->
    <div x-show="recorderState === 'idle' || recorderState === 'success'">
      <!-- Start game button (before game starts) -->
      <div x-show="!gameStarted" class="flex items-center gap-2 mb-1.5">
        <button
          @click="startGame()"
          :disabled="isLoading || gameBlocked"
          class="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium text-sm whitespace-nowrap"
        >
          Start a new game
        </button>
        <span class="text-xs text-gray-600">or write your own opening below</span>
      </div>

      <!-- Choice buttons (after game starts) -->
      <div x-show="gameStarted" class="grid grid-cols-2 gap-1.5 mb-1.5">
        <button
          @click="sendChoice(1)"
          :disabled="isLoading || !choice1Text.trim() || gameBlocked"
          class="w-full px-2 py-1.5 rounded border border-gray-300 bg-white hover:bg-gray-100 disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed text-left text-xs truncate"
          title="Choice 1"
          x-text="choice1Text || 'Waiting for choices‚Ä¶'"
        >
        </button>

        <button
          @click="sendChoice(2)"
          :disabled="isLoading || !choice2Text.trim() || gameBlocked"
          class="w-full px-2 py-1.5 rounded border border-gray-300 bg-white hover:bg-gray-100 disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed text-left text-xs truncate"
          title="Choice 2"
          x-text="choice2Text || 'Waiting for choices‚Ä¶'"
        >
        </button>
      </div>

      <!-- Text input row -->
      <div class="flex gap-1.5">
        <textarea
          x-model="inputMessage"
          @keydown.enter.prevent="sendMessage()"
          @input="autoResize($event.target); saveDraft()"
          x-ref="messageInput"
          :disabled="isLoading || gameBlocked"
          placeholder="Type your action‚Ä¶"
          rows="1"
          class="flex-1 px-2 py-1.5 border border-gray-300 rounded focus:ring-1 focus:ring-indigo-500 focus:border-transparent text-sm resize-none overflow-hidden"
          style="min-height: 34px; max-height: 130px;"
        ></textarea>

        <button
          @click="sendMessage()"
          :disabled="isLoading || !inputMessage.trim() || gameBlocked"
          class="px-3 py-1.5 bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium text-sm"
        >
          Send
        </button>

        <button
          @click="toggleRecording()"
          :disabled="isLoading || gameBlocked"
          :class="recorderState === 'idle' ? 'bg-gray-200 hover:bg-red-100 hover:text-red-600' : 'bg-red-500 text-white'"
          class="px-2 py-1.5 text-gray-700 rounded text-sm transition-colors"
          :title="recorderState === 'idle' ? 'Start recording' : 'Recording...'"
        >
          üé§
        </button>
      </div>
    </div>
  </div>

  <!-- Refusal Details Modal -->
  <div
    x-show="showRefusalModal"
    @click.self="showRefusalModal = false"
    x-cloak
    class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
  >
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden flex flex-col">
      <!-- Modal header -->
      <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
        <h3 class="text-lg font-semibold text-gray-900">Turn Correction Details</h3>
        <button
          @click="showRefusalModal = false"
          class="text-gray-400 hover:text-gray-600 text-2xl leading-none"
        >
          √ó
        </button>
      </div>
      
      <!-- Modal content -->
      <div class="px-4 py-3 overflow-y-auto flex-1">
        <template x-if="activeRefusalInfo">
          <div class="space-y-4">
            <!-- Correction status -->
            <div>
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-1">Status</div>
              <div class="text-sm">
                <span
                  x-show="activeRefusalInfo.was_corrected"
                  class="inline-flex items-center px-2 py-1 rounded bg-green-100 text-green-800 font-medium"
                >
                  ‚úì Successfully corrected
                </span>
                <span
                  x-show="activeRefusalInfo.turn_1_refusal"
                  class="inline-flex items-center px-2 py-1 rounded bg-red-100 text-red-800 font-medium"
                >
                  ‚úó Turn 1 refusal (not correctable)
                </span>
                <span
                  x-show="activeRefusalInfo.all_attempts_failed"
                  class="inline-flex items-center px-2 py-1 rounded bg-red-100 text-red-800 font-medium"
                >
                  ‚úó Failed after 3 attempts
                </span>
                <span
                  x-show="!activeRefusalInfo.was_corrected && !activeRefusalInfo.turn_1_refusal && !activeRefusalInfo.all_attempts_failed"
                  class="inline-flex items-center px-2 py-1 rounded bg-yellow-100 text-yellow-800 font-medium"
                >
                  ‚ö† Detected but not corrected
                </span>
              </div>
            </div>
            
            <!-- All attempts (if multiple) -->
            <div x-show="activeRefusalInfo.attempts && activeRefusalInfo.attempts.length > 0">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2">Correction Attempts</div>
              <div class="space-y-3">
                <template x-for="(attempt, idx) in activeRefusalInfo.attempts" :key="idx">
                  <div class="border rounded p-3" :class="attempt.was_refusal ? 'border-red-200 bg-red-50' : 'border-green-200 bg-green-50'">
                    <!-- Attempt header -->
                    <div class="flex items-center justify-between mb-2">
                      <div class="font-semibold text-sm">
                        <span x-text="`Attempt ${attempt.attempt_number}`"></span>
                        <span x-show="attempt.attempt_number === 1" class="text-gray-500 text-xs ml-1">(original)</span>
                      </div>
                      <div class="text-xs font-medium" :class="attempt.was_refusal ? 'text-red-600' : 'text-green-600'">
                        <span x-show="attempt.was_refusal">‚ùå Refusal</span>
                        <span x-show="!attempt.was_refusal">‚úÖ Valid</span>
                      </div>
                    </div>
                    
                    <!-- Classifier response -->
                    <div class="mb-2">
                      <div class="text-xs text-gray-600 mb-1">Classifier:</div>
                      <div class="text-xs bg-white rounded p-2 whitespace-pre-wrap" x-text="attempt.classifier_response"></div>
                    </div>
                    
                    <!-- Turn text (if not the final successful one) -->
                    <div x-show="attempt.turn_text && (attempt.was_refusal || idx < activeRefusalInfo.attempts.length - 1)">
                      <div class="text-xs text-gray-600 mb-1">Generated text:</div>
                      <div class="text-xs bg-white rounded p-2 whitespace-pre-wrap max-h-32 overflow-y-auto" x-text="attempt.turn_text"></div>
                    </div>
                    
                    <!-- Error indicator -->
                    <div x-show="attempt.error" class="mt-2 text-xs text-red-600">
                      Generation error occurred
                    </div>
                  </div>
                </template>
              </div>
            </div>
            
            <!-- Fallback: Old single classifier response (for backward compatibility) -->
            <div x-show="!activeRefusalInfo.attempts || activeRefusalInfo.attempts.length === 0">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-1">Classifier Response</div>
              <div class="text-sm bg-gray-50 rounded p-3 whitespace-pre-wrap" x-text="activeRefusalInfo.classifier_response"></div>
            </div>
            
            <!-- Original text (if different from corrected) - old format -->
            <div x-show="activeRefusalInfo.was_corrected && activeRefusalInfo.original_text && (!activeRefusalInfo.attempts || activeRefusalInfo.attempts.length === 0)">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-1">Original Response (Before Correction)</div>
              <div class="text-sm bg-red-50 rounded p-3 whitespace-pre-wrap border border-red-200" x-text="activeRefusalInfo.original_text"></div>
            </div>
          </div>
        </template>
      </div>
      
      <!-- Modal footer -->
      <div class="px-4 py-3 border-t border-gray-200 flex justify-end">
        <button
          @click="showRefusalModal = false"
          class="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 font-medium text-sm"
        >
          Close
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Judge Details Modal -->
<div
  x-show="showJudgeModal"
  x-cloak
  class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
  @click.self="showJudgeModal = false"
>
  <div class="bg-white rounded-lg shadow-xl max-w-3xl w-full mx-4 max-h-[80vh] overflow-hidden">
    <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200">
      <h3 class="text-lg font-semibold text-gray-900">Judge Pipeline Details</h3>
      <button @click="showJudgeModal = false" class="text-gray-400 hover:text-gray-600">‚úï</button>
    </div>

    <div class="p-4 space-y-4 max-h-[65vh] overflow-y-auto">
      <template x-if="activeJudgeInfo">
        <div>
          <div class="text-sm text-gray-700 mb-2">
            <span class="font-semibold">Modified:</span>
            <span x-text="activeJudgeInfo.was_modified ? 'Yes' : 'No'"></span>
          </div>

          <div class="space-y-3" x-show="activeJudgeInfo.steps && activeJudgeInfo.steps.length">
            <template x-for="(step, idx) in activeJudgeInfo.steps" :key="idx">
              <div class="border rounded p-3" :class="step.used_rewrite ? 'border-purple-200 bg-purple-50' : 'border-gray-200 bg-gray-50'">
                <div class="flex items-center justify-between">
                  <div class="text-sm font-semibold text-gray-800" x-text="step.name || ('Step ' + (idx + 1))"></div>
                  <div class="text-xs text-gray-500" x-text="step.used_rewrite ? 'Rewrite applied' : 'No rewrite' "></div>
                </div>
                <div class="mt-2">
                  <div class="text-xs text-gray-500">Judge Response</div>
                  <div class="text-sm bg-white rounded p-2 whitespace-pre-wrap" x-text="step.judge_response"></div>
                </div>
                <div class="mt-2" x-show="step.rewrite_response">
                  <div class="text-xs text-gray-500">Rewrite Output</div>
                  <div class="text-sm bg-white rounded p-2 whitespace-pre-wrap" x-text="step.rewrite_response"></div>
                </div>
                <div class="mt-2" x-show="step.compare_response">
                  <div class="text-xs text-gray-500">Comparison Response</div>
                  <div class="text-sm bg-white rounded p-2 whitespace-pre-wrap" x-text="step.compare_response"></div>
                </div>
                <div class="mt-2 text-xs text-gray-600" x-show="step.error">Error: <span x-text="step.error"></span></div>
              </div>
            </template>
          </div>

          <div class="text-sm text-gray-500" x-show="!activeJudgeInfo.steps || activeJudgeInfo.steps.length === 0">
            No judge steps were executed.
          </div>
        </div>
      </template>
    </div>

    <div class="px-4 py-3 border-t border-gray-200 flex justify-end">
      <button
        @click="showJudgeModal = false"
        class="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 font-medium text-sm"
      >
        Close
      </button>
    </div>
  </div>
</div>

<script>
function chatApp() {
  return {
    conversationId: null,
    conversationTitle: 'New Conversation',
    messages: [],
    inputMessage: '',
    isLoading: false,
    errorMessage: '',
    gameStarted: false,
    gameBlocked: false,

    // Game-state placeholders
    inventoryItems: [],
    turnCurrent: 0,
    turnMax: 20,

    // Choice placeholders
    choice1Text: '',
    choice2Text: '',
    
    // Refusal info tracking
    activeRefusalInfo: null,
    showRefusalModal: false,
    // Judge info tracking
    activeJudgeInfo: null,
    showJudgeModal: false,
    
    // Recording state
    recorderState: 'idle',  // idle, recording, processing, error, success
    recorderError: '',
    recorderLevel: 0,
    recorderTimeDisplay: '00:00',
    recorderInitialized: false,

    async init() {
      const urlParams = new URLSearchParams(window.location.search);
      const convId = urlParams.get('conversation_id');

      if (convId) {
        await this.loadConversation(convId);
      } else {
        await this.newConversation();
      }
      
      // Initialize recorder
      await this.initRecorder();
      
      // Clear draft when page is about to unload (user navigating away)
      window.addEventListener('beforeunload', () => {
        CYOARecorder.clearDraftText();
      });
    },
    
    async initRecorder() {
      if (this.recorderInitialized) return;
      
      try {
        const pending = await CYOARecorder.init({
          onStateChange: (state, error) => {
            this.recorderState = state;
            this.recorderError = error || '';
            
            // If success, the transcript will be handled by onTranscriptReady
            if (state === 'success') {
              // Brief delay then return to idle
              setTimeout(() => {
                this.recorderState = 'idle';
              }, 100);
            }
          },
          onTranscriptReady: (transcript) => {
            this.insertTranscript(transcript);
            // Once inserted, we can discard the recording so it doesn't come back on reload
            CYOARecorder.discardRecording();
          },
          onLevelUpdate: (level) => {
            this.recorderLevel = level;
          },
          onTimeUpdate: (ms) => {
            this.recorderTimeDisplay = CYOARecorder.formatTime(ms);
          }
        });
        
        this.recorderInitialized = true;
        
        // Load any saved draft text
        const savedDraft = CYOARecorder.loadDraftText();
        if (savedDraft && !this.inputMessage) {
          this.inputMessage = savedDraft;
        }
        
        // Handle pending recording from page reload
        if (pending) {
          console.log('Found pending recording:', pending);
          
          if (pending.status === 'transcribed' && pending.transcript) {
            // Already transcribed, insert it
            this.insertTranscript(pending.transcript);
            CYOARecorder.discardRecording();
          } else if (pending.status === 'failed') {
            // Show error state so user can retry
            this.recorderState = 'error';
            this.recorderError = pending.error || 'Previous transcription failed';
          } else if (pending.status === 'processing' || pending.status === 'pending') {
            // Show processing state and retry
            this.recorderState = 'processing';
            setTimeout(() => {
              CYOARecorder.retryTranscription();
            }, 500);
          }
        }
        
      } catch (e) {
        console.error('Failed to initialize recorder:', e);
      }
    },
    
    toggleRecording() {
      if (this.recorderState === 'idle') {
        CYOARecorder.startRecording();
      } else if (this.recorderState === 'recording') {
        CYOARecorder.stopRecording();
      }
    },
    
    stopRecording() {
      CYOARecorder.stopRecording();
    },
    
    cancelRecording() {
      // Use the new cancelRecording method from the recorder module
      CYOARecorder.cancelRecording();
    },
    
    retryTranscription() {
      CYOARecorder.retryTranscription();
    },
    
    discardRecording() {
      CYOARecorder.discardRecording();
    },
    
    downloadRecording() {
      CYOARecorder.downloadRecording();
    },
    
    insertTranscript(transcript) {
      if (!transcript) return;
      
      const textarea = this.$refs.messageInput;
      const currentText = this.inputMessage;
      
      if (!textarea) {
        // Fallback: just append
        this.inputMessage = currentText ? currentText + ' ' + transcript : transcript;
        return;
      }
      
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      
      if (start !== end) {
        // Replace selection
        this.inputMessage = currentText.slice(0, start) + transcript + currentText.slice(end);
        // Set cursor after inserted text
        this.$nextTick(() => {
          textarea.selectionStart = textarea.selectionEnd = start + transcript.length;
          textarea.focus();
        });
      } else if (currentText) {
        // Append with space at cursor position
        const before = currentText.slice(0, start);
        const after = currentText.slice(start);
        const needsSpace = before && !before.endsWith(' ') && !before.endsWith('\n');
        this.inputMessage = before + (needsSpace ? ' ' : '') + transcript + after;
        this.$nextTick(() => {
          const newPos = start + (needsSpace ? 1 : 0) + transcript.length;
          textarea.selectionStart = textarea.selectionEnd = newPos;
          textarea.focus();
        });
      } else {
        // Empty input, just set the transcript
        this.inputMessage = transcript;
        this.$nextTick(() => {
          textarea.focus();
        });
      }
      
      // Auto-resize textarea
      this.$nextTick(() => {
        // Use a small timeout to ensure DOM update is complete before resizing
        setTimeout(() => {
            this.autoResize(textarea);
            // Save draft with the new transcript so it persists on reload
            this.saveDraft();
        }, 10);
      });
      
      // We process the draft saving in the timeout above, so we don't clear it here
      // CYOARecorder.clearDraftText();
    },
    
    saveDraft() {
      CYOARecorder.saveDraftText(this.inputMessage);
    },
    
    viewRefusalDetails(message) {
      // Extract refusal info from message
      const refusalInfo = message.refusal_info || (message.metadata && message.metadata.refusal_info);
      if (refusalInfo) {
        this.activeRefusalInfo = refusalInfo;
        this.showRefusalModal = true;
      }
    },

    viewJudgeDetails(message) {
      const judgeInfo = message.judge_info || (message.metadata && message.metadata.judge_info);
      if (judgeInfo) {
        this.activeJudgeInfo = judgeInfo;
        this.showJudgeModal = true;
      }
    },

    async newConversation() {
      try {
        // Get config_id from URL if present
        const urlParams = new URLSearchParams(window.location.search);
        const configId = urlParams.get('config');
        
        const body = configId ? JSON.stringify({ config_id: parseInt(configId) }) : JSON.stringify({});
        
        const response = await fetch('/chat/api/new', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: body
        });

        const data = await response.json();

        if (data.conversation_id) {
          this.conversationId = data.conversation_id;
          this.conversationTitle = data.title;
          this.messages = [];
          this.errorMessage = '';

          // Reset game state for new run
          this.inventoryItems = [];
          this.turnCurrent = 0;
          this.choice1Text = '';
          this.choice2Text = '';
          this.gameStarted = false;
          this.gameBlocked = false;
          
          // Clear input and draft when starting new conversation
          this.inputMessage = '';
          CYOARecorder.clearDraftText();

          window.history.pushState({}, '', `/chat/?conversation_id=${this.conversationId}`);
        }
      } catch (error) {
        this.errorMessage = 'Failed to create new conversation: ' + error.message;
      }
    },

    async loadConversation(convId) {
      try {
        const response = await fetch(`/chat/api/conversation/${convId}`);
        const data = await response.json();

        if (data.conversation_id) {
          this.conversationId = data.conversation_id;
          this.conversationTitle = data.title;
          this.messages = data.messages || [];
          
          this.restoreGameState();
          this.scrollToBottom();
        }
      } catch (error) {
        this.errorMessage = 'Failed to load conversation: ' + error.message;
      }
    },

    async startGame() {
      this.inputMessage = 'Start';
      await this.sendMessage();
    },

    async sendChoice(which) {
      const text = (which === 1 ? this.choice1Text : this.choice2Text).trim();
      if (!text || this.isLoading) return;
      this.inputMessage = text;
      await this.sendMessage();
    },

    async sendMessage() {
      if (!this.inputMessage.trim() || this.isLoading) return;

      const userMessage = this.inputMessage.trim();
      this.inputMessage = '';
      
      // Clear draft
      CYOARecorder.clearDraftText();
      
      // Reset textarea height
      if (this.$refs.messageInput) {
        this.$refs.messageInput.style.height = '34px';
        this.$refs.messageInput.style.overflowY = 'hidden';
      }
      
      this.isLoading = true;
      this.errorMessage = '';

      this.messages.push({
        role: 'user',
        content: userMessage,
        created_at: new Date().toISOString()
      });

      this.scrollToBottom();

      try {
        const response = await fetch('/chat/api/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversation_id: this.conversationId,
            message: userMessage
          })
        });

        const data = await response.json();

        if (data.error) {
          // Only show generic errors in the banner
          this.errorMessage = data.error;
        } else if (data.message) {
          // Push the message (even if it's an error message)
          this.messages.push(data.message);
          this.scrollToBottom();

          // Mark game as started once we get a response
          this.gameStarted = true;
          
          // Block game if indicated by backend
          if (data.game_blocked) {
            this.gameBlocked = true;
          }

          // Update game state if backend returns it
          if (data.state) {
            if (Array.isArray(data.state.inventory)) this.inventoryItems = data.state.inventory;
            if (typeof data.state.turn_current === 'number') this.turnCurrent = data.state.turn_current;
            if (typeof data.state.turn_max === 'number') this.turnMax = data.state.turn_max;
            if (typeof data.state.choice1 === 'string') this.choice1Text = data.state.choice1;
            if (typeof data.state.choice2 === 'string') this.choice2Text = data.state.choice2;
          }
        }
      } catch (error) {
        this.errorMessage = 'Failed to send message: ' + error.message;
      } finally {
        this.isLoading = false;
      }
    },

    scrollToBottom() {
      this.$nextTick(() => {
        const container = this.$refs.messagesContainer;
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      });
    },

    restoreGameState() {
      if (this.messages.length === 0) {
        this.gameStarted = false;
        return;
      }

      this.gameStarted = true;
      
      // Find the last assistant message to extract state (refusal info now per-message)
      for (let i = this.messages.length - 1; i >= 0; i--) {
        if (this.messages[i].role === 'assistant') {
          const message = this.messages[i];
          const text = message.content;
          
          // Check if this is an error message - if so, block the game
          if (message.metadata && message.metadata.is_error) {
            this.gameBlocked = true;
          }
          
          // Extract Turn X of Y
          const turnMatch = text.match(/Turn\s+(\d+)\s+(?:of|\/)\s+(\d+)/i);
          if (turnMatch) {
            this.turnCurrent = parseInt(turnMatch[1]);
            this.turnMax = parseInt(turnMatch[2]);
          }
          
          // Extract choices "1) ... 2) ..."
          const choice1Match = text.match(/1\)\s*(.+?)(?=\n|$)/);
          const choice2Match = text.match(/2\)\s*(.+?)(?=\n|$)/);
          
          if (choice1Match) this.choice1Text = choice1Match[1].trim();
          if (choice2Match) this.choice2Text = choice2Match[1].trim();
          
          break;
        }
      }
    },

    autoResize(textarea) {
      if (!textarea) return;
      
      // Reset height to get accurate scrollHeight
      textarea.style.height = '34px';
      
      // Calculate new height (max 5 lines ~130px)
      const newHeight = Math.min(textarea.scrollHeight, 130);
      textarea.style.height = newHeight + 'px';
      
      // Enable scrolling if content exceeds max height
      if (textarea.scrollHeight > 130) {
        textarea.style.overflowY = 'auto';
      } else {
        textarea.style.overflowY = 'hidden';
      }
    }
  }
}
</script>
</body>
</html>
